

参考
* [前端该如何准备数据结构和算法？](https://juejin.im/post/5d5b307b5188253da24d3cd1#heading-41)
* [LeetCode 探索](https://leetcode-cn.com/explore/)，强烈推荐按课程学习

常见的数据结构有
* 有序数据结构：栈、队列、链表，有序数据结构省空间（存储空间小）
* 无序数据结构：集合、字典、散列表，无序数据结构省时间（读取时间快）
* 复杂数据结构，树、堆、图


## 树

### 树的前、中、后序遍历？如何使用非递归实现？

非递归则使用一个栈来维护节点的访问顺序

### 根据中序、后序遍历，还原树的结构？
[letcode传送门](https://leetcode-cn.com/explore/learn/card/data-structure-binary-tree/4/conclusion/15/)

* 先从后序遍历找到根节点，
* 然后找到根节点在中序遍历中的顺序，其左侧为中序左子树，右侧为中序右子树
* 根据中序左子树的长度，从后序遍历开始找到后序左子树；后序右子树同理
* 递归构建左子树和右子树

根据前序、中序遍历还原树的思路基本保持一致。

### 判断二叉树是否为对称二叉树
二叉树的右子树是二叉树左子树的镜像二叉树。

镜像二叉树：两颗二叉树根结点相同，但他们的左右两个子节点交换了位置。

递归判断`node1.left`和`node2.right`以及`node1.right`与`node2.left`

### 翻转二叉树
递归交换二叉树所有节点的左右节点的位置

### 二叉树的最大、最小深度

一棵二叉树的最大深度等于左子树深度和右子树最大深度的最大值 + 1，因此通过递归处理

最小深度同理

### 判断树是否为平衡二叉树

平衡二叉树中，每个子树的深度之差不超过1

递归判断左右子树是否为平衡二叉树

### 二叉搜索树的第k小的节点
二叉搜索树的中序遍历即排序后的节点，因此先中序遍历，然后在返回索引值为k的节点值即可

### 给定一个数组，判断是否为二叉搜索树的后序遍历
* 首先确定根节点，为后序遍历的最后一个值
* 确认左右子树，左子树全部比根节点小，右子树全部比根节点大
* 递归判断左右子树


## 链表

主要考察
* 链表的遍历
* 有环链表
* 双指针

### 从后向前遍历单链表

从前向后遍历时，使用一个队列来保存遍历的节点，每次从头部插入新节点

该方法可以实现翻转链表

### O(1)时间内删除链表中的指定节点

* 删除的节点不是尾部节点： 使用待删除的节点的next节点值覆盖当前节点值，然后删除下一个节点
* 删除的节点是尾部节点且等于头节点，只剩一个节点 ： 将头节点置为null
* 删除的节点是尾节点且前面还有节点：遍历到末尾的前一个节点删除

### 复制带随机指针的链表

[letcode传送门](https://leetcode-cn.com/explore/learn/card/linked-list/197/conclusion/766/)

* 首先通过next遍历链表，使用一个栈st保存每个节点
* 然后使用st克隆一堆链表节点nodes，不带next和random属性
* 遍历st，根据`st.indexOf`扎到随机节点的索引值index，依次设置每个节点的random为nodes[index]和next为nodes[i+1]

### 判断链表是否有环

使用快慢指针，快指针每次移动两步、慢指针每次移动一步，如果在某个时刻快慢指针重合则表示有环

### 如果链表有环，找到入环节点
[letcode传送门](https://leetcode-cn.com/explore/learn/card/linked-list/194/two-pointer-technique/745/)

* 首先使用快慢指针判断有环，并从第一次相遇的节点开始进行标记count，
* 然后继续循环count++至第二次相遇时，此时count表示的就是环的长度
* 得到环的长度之后，将快慢指针同时指向head，并将快指针提前移动count步，后续每次循环时快慢指针都走一步，下次相遇时则为开始起环的节点

### 约瑟夫环

> 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

* 用链表模拟一个环
* 模拟游戏场景
* 记录头节点的前一个节点current，以保证我们找到的要删除的节点是current.next
* 每次循环m次找到目标节点删除，直到链表只剩下一个节点

参考:[数组、链表、递归三种方式解决约瑟夫环](https://mp.weixin.qq.com/s/xBiQHKdSop1HzKTF7EVhCQ)

### 判断链表是否相交

https://leetcode-cn.com/explore/learn/card/linked-list/194/two-pointer-technique/746/

把两个单链表看作是两段线段，以两条线段相加的和不变这个条件，分别遍历两个链表。

参考: https://blog.csdn.net/qq_34364995/article/details/80518198

![](http://ww4.sinaimg.cn/large/006tNc79gy1g4adqu9i8hj31bq0q2tuc.jpg)

现有线段ACD和线段BCD，两条线段相交于C点。同时从A、B分别开始遍历ACD和BCD，遍历点记为PA和PB，经过的长度用len记录，遍历步长为1。当PA遍历到D时，PB在I，此时len为5。由于ACD已经遍历完，PA就跳到B点开始遍历BCD。当BCD遍历完时，PB跳转到A。

分解一下PA和PB的遍历轨迹就是，
* PA：AECHIDBFGC。
* PB：BFGCHIDAEC。


### 两个链表的公共节点
使用快慢指针
* 先找到两个链表的长度length1、length2
* 让长一点的链表先走length2-length1步，让长链表和短链表起点相同
* 两个链表一起前进，比较获得第一个相等的节点

### 删除倒数第k个节点

先遍历获取链表的长度len，然后再遍历到len-k处删除节点，需遍历两次

可以优化为：使用快慢指针，快指针先移动k步，然后快慢指针一起移动，当快指针到达末尾时，慢指针对应的就是第k个节点

## 数组

### 调整数组顺序使奇数位于偶数前面
使用前后两个指针，前后同时遍历，头指针遇见偶数、尾指针遇见奇数时交换位置


### 从增序数组中找到和为S的两个数

* 设定一个小索引left，从0开始，设定一个大索引right，从array.length开始
* 判断array[left] + array[right]的值s是否符合条件
* 符合条件 - 返回
* 大于sum，right向左移动；小于sum，left向右移动
* 若left=right，没有符合条件的结果

### 连续子数组的最大和

[letcode传送门](https://leetcode-cn.com/explore/featured/card/array-and-string/201/two-pointer-technique/789/)

* 记录一个当前连续子数组最大值 max 默认值为数组第一项
* 记录一个当前连续子数组累加值 sum 默认值为数组第一项
* 从数组第二个数开始，若 sum<0 则当前的sum不再对后面的累加有贡献，sum = 当前数
* 若 sum>0 则sum = sum + 当前数
* 比较 sum 和 max ，max = 两者最大值


## 栈

### 实现最小栈

使用两个栈，一个栈A保存原始数据，一个栈B在每次入栈时与B栈顶元素进行比较，如果比其小则入栈，如果比起大则将栈顶元素再次入栈，保证栈顶是最小元素。两个栈出栈时需要同时出栈。

### 给定栈的入栈顺序，判断给定列表是否满足其出栈顺序

[参考](http://www.conardli.top/docs/dataStructure/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF)

入栈顺序pushV`[1,2,3,4,5]`，判断出栈顺序popV`[4,5,3,2,1]`是否合法
* 首先找到popV顶部的元素4，然后将pushV中该idx对应索引值后面的元素[5]认为未入栈，则pushV为[1,2,3,4]
* 将popV和pushV顶部元素4弹出，重复步骤1，popV[1,2,3,4]顶部元素为5，pushV中不包含5，则从未入栈元素中一次入栈，直至找到5为止,此时pushV为[1,2,3,5]
* 当pushV为空时表示满足出栈顺序

### 滑动窗口最大值

