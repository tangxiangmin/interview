
## HTTP

参考之前整理的[HTTP系列](https://www.shymean.com/archive/HTTP)

HTTP：超文本传输协议（英文：`HyperText Transfer Protocol`，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议，是万维网的数据通信的基础。

HTTP报文是浏览器和服务器之间发送的数据块，报文主要包含三个部分
* 对报文进行描述的起始行
* 包含属性的首部块
* 可选的，包含数据的主体部分

请求报文和响应报文最主要的结构区别在于起始行不一样：
* 请求报文的首部行包含请求方法，资源URL和HTTP版本号
* 响应报文包含HTTP版本号，请求资源的响应状态（一个三位数）和原因短语（一个英语短语文本）


### 常见的请求方法

GET和POST的区别，就日常使用经验来看
* 目的不同，Get是用来从服务器上获得数据，而Post是用来向服务器上传递数据。
* 传递请求数据的方式不同，GET将参数添加在URL的查询字段后（URL位于请求报文的起始行），而POST将请求数据放在请求报文的主体部分
* 由于浏览器可能缓存带有查询字段的URL，因此不能保证安全而被其他访问者查看；此外，某些浏览器对于URL的长度是有限制的，服务器一般也对URL长度有某些限制（超过会返回414错误），因此在需要向服务器传递大量数据的时候一般使用POST方法

但是需要认识到，HTTP最初设定了八种请求方法。这些方法方法本质上没有任何区别。只是让请求更加有语义而已，只是由于浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。因此关于GET和POST的区别
* 主要在于语义化含义，以及服务器的一些限制而已
* 貌似部分浏览器和框架对于GET会发送一个TCP包，POST会发送两个包，但并不全是这样，具体可以参考[这里](https://blog.csdn.net/zerooffdate/article/details/78962818)

### 首部行字段
参考：[前端必备HTTP技能之HTTP请求头响应头中常用字段详解](http://www.jianshu.com/p/6e86903d74f7)

首部行携带了一些关于报文的原始信息，可分为通用首部、请求首部、响应首部、实体首部等。

### 常见的状态码

状态码是一个三位数，第一位描述状态的一般类别（成功，失败...），后两位描述状态的详细信息
* 1表示信息提示
* 2表示请求成功
* 3表示重定向，要么告知客户端使用替代位置来访问他们感兴趣的资源，要么是服务器提供一个替代的响应而不是请求资源的内容
* 4表示客户端错误，指浏览器发送了服务器无法处理的内容
* 5表示服务端错误

[HTTP常见状态码](https://www.cnblogs.com/starof/p/5035119.html)

### keep-alive

在早期，当一个http请求响应完毕后，就会断开本次tcp连接。如果http请求比较频繁，这种为单个请求建立tcp连接的方式就比较浪费。

可以通过配置`Connection：keep-alive`和`Keep-Alive:timeout=x,max=xx`的响应头来改善这种状态。

可以理解为HTTP的 `keep-alive`是为了让tcp活得更久一点：当一个http相应完毕后，理应立即关闭本次链接，服务端此时会等待`timeout`秒，然后才关闭这个链接。

## HTTP缓存

缓存的好处:
* 减轻了服务器的压力，服务器不必为来自同一个客户端的资源请求进行重复处理
* 提高了客户端的加载速度，从本地或者就近的缓存中读取资源，比从遥远的服务器获取资源要快得多

下面是与缓存相关的一些条件请求头部
* `if-Modified-Since` 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified
* `If-None-Match`设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified
* `If-Match`设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源
* `If-Range`设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体
* `If-Unmodified-Since` 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应

下面是强缓存和协商缓存的相关流程
```
@startuml  cache
start
:请求资源;
if(浏览器私有缓存) then (Y)
    if(新鲜度检测) then(Y)
        :200(from cache);
        stop
    else (N)
        if(服务器再验证) then(Y)
            :HTTP 304;
            :浏览器更新新鲜度;
            :304(not modified);
            stop
        endif
    endif
else (N)
    :未命中缓存，直接请求资源;
endif

if(资源存在) then(Y)
    :新内存存入缓存;
    :HTTP 200;
    stop
else 
    :HTTP 404;
    stop
@enduml
```
![](http://img.shymean.com/oPic/1620227891123_947.png)

## 身份识别 

### Cookie

Cookie是服务器发送到用户浏览器并保存在浏览器上的一块数据，它会在浏览器下一次发起请求时被携带并发送到服务器上。Cookie的使用使得基于无状态的HTTP协议上记录稳定的状态信息成为了可能。

Cookie非常依赖于浏览器，不同浏览器之间的Cookie是不能通用的。可以笼统地将Cookie分为两类：会话Cookie和持久Cookie:
* 会话Cookie是临时Cookie，用户退出浏览器时Cookie就被删除了（并不是关闭标签页就删除哦）
* 持久Cookie是指会被保存在硬盘上的Cookie信息，浏览器退出，计算机重启时他们仍然存在。
* 会话Cookie与持久Cookie的区别在于是否为他们设置了过期时间（马上就会提到），如果没有，则为会话Cookie。接下来看看服务器是如何在响应报文中设置Cookie的

服务端通过响应报文的`Set-Cookie`字段设置Cookie
```
Set-Cookie: <cookie-name>=<cookie-value>; [Domain=<domain-value>;][Secure;][HttpOnly;][Expires=<date>][Max-Age=<non-zero-digit>][Path=<path-value>]
```

需要注意服务端`Set-Cookie`一些特殊的修饰符
* `Secure`，表示只有在HTTP使用SSL安全连接时才发送该cookie
* `HttpOnly`，表示该Cookie无法被客户端Javascript操作

浏览器通过请求报文的`Cookie`字段发送Cookie
```
Cookie: name=value; name2=value2; name3=value3
```

在浏览器中可以通过`document.cookie`来操作cookie。

### Session

Cookie将用户身份信息保存在浏览器，并在每次请求时携带对应信息到服务器。此外，在服务器保存用户身份的做法是可行的，这种方式称为`Session`。维持session会话的核心就是客户端的唯一标识，即SessionID，SessionID就像是用户的身份证账号一样，只需要提供值，服务器就会自动检索并查找到用户的身份信息。

传递sessionId一般有下面几种方式
* 最常用的方式是通过Cookie
* 通过URL参数
* 通过表单隐藏字段

服务器使用类似于散列表的结构来保存多个用户的信息，每个用户的信息使用SessionID来索引，这就是SessionID必须唯一且不能被伪造的原因。 用户信息可以保存在内存中，文件中或者数据库中。

## HTTPS原理
参考：[升级博客到HTTPS](https://www.shymean.com/article/%E5%8D%87%E7%BA%A7%E5%8D%9A%E5%AE%A2%E5%88%B0HTTPS)，后面用伪代码整理了https的基本原理。

超文本传输安全协议（Hypertext Transfer Protocol Secure）HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：
* 内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。
* 身份认证。通过校验保证客户端访问的是自己的服务器。
* 数据完整性。防止内容被第三方冒充或者篡改。

需要了解两种加密方式
* 对称加密，服务端和客户端的加密和解密都使用相同的加密和解密方式，效率比较高，缺点是第一次发送时密钥可能被盗取，常见的对称加密算法有`DES`、`AES`等
* 公开密钥加密，服务端和客户端使用独立的加密解密方法，并通过对方的加密方法加密需要发送的报文，通过自己的解密方法接收对方发送的报文，安全性比较高，缺点是效率比较低，常见的非对称密钥加密算法有`RSA`、`DSA`等

为了提高安全性和效率，HTTPS结合了对称和非对称两种加密方式：在握手阶段使用公开密钥加密选择一种对称加密算法和密钥，然后在后续的通信阶段使用选择的对称加密算法和密钥进行通信。

使用公开密钥方式仍旧存在缺点，即无法保证传输的公开密钥是货真价实的，因此还需要使用数字证书，数字证书通常是由受信任的数字证书颁发机构CA，公钥就被包含在数字证书中。
* 在验证服务器身份后颁发证书，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。
* 在建立链接时，服务端发送者证书和到客户端，客户端使用证书对比签名，确认证书内的公钥是否是合法的，
* 如果是合法的，则将选择的某种对称加密方式加密后发送至服务端，完成密钥协商，然后继续后续的报文加密

为什么证书可以确保公开密钥的真实性呢？这是因为，证书是不能被伪造的，在签发证书时就会验证域名及域名所有者的身份。浏览器和系统内置了默认信任的证书，验证证书的过程如下
* 检查SSL证书是否由浏览器中“受信任的根证书颁发机构”颁发
* 检查部署SSL证书的网站域名是否与证书中一致
* 检查SSL证书中的证书吊销列表，证书是否被颁发机构吊销
* 检查此SSL证书是否过期
* 浏览器会到欺诈网站数据库查询此网站是否被列入黑名单

## HTTP2新特性
参考
* [从理论到实践 全面理解HTTP/2](https://juejin.im/post/5c6a9f85e51d4503831ad4fa)

### 二进制格式传输与多路复用

在HTTP/2中，新增了二进制分帧层，将数据转换成二进制，也就是说HTTP/2中所有的内容都是采用二进制传输

帧是HTTP/2中数据传输的最小单位；每个帧都有stream_ID字段，表示这个帧属于哪个流，接收方把stream_ID相同的所有帧组合到一起就是被传输的内容了。HTTP/2共定义了十种帧，较为常见的有数据帧、头部帧、PING帧、SETTING帧、优先级帧和PUSH_PROMISE帧等，为将来的高级应用打好了基础

在这种**多路复用**传输模式下，HTTP请求变得十分廉价，我们不需要再时刻顾虑网站的http请求数是否太多、TCP连接数是否太多、是否会产生阻塞等问题了。

### HPACK 首部压缩
HTTP/1中，每个请求和响应都会携带对应的头部信息，每个页面的请求越多，越来越多的请求导致消耗在头部的流量越来越多，尤其是每次都要传输 UserAgent、Cookie 这类不会频繁变动的内容，完全是一种浪费

为了减少冗余的头部信息带来的消耗，HTTP/2采用HPACK 算法压缩请求和响应的header。其具体原理为
* 通信双方共同维护了一份静态表，包含了常见的头部名称与值的组合（比如method:GET，可以存在表中，然后只需要传递一个键名即可）
* 根据先入先出的原则，维护一份可动态添加内容的动态表
* 用基于该静态哈夫曼码表的哈夫曼编码数据

这样可以极大地节省头部的消耗

### server push

HTTP/2的server push允许服务器在未收到请求时主动向浏览器推送资源。这样可以将资源提前推送到到浏览器：除了静态文件，还可以推送比较耗时的API

在HTTP1.1时代，也有提前获取资源的方法，如preload和prefetch，
* preload是在页面解析初期就告诉浏览器，这个资源是浏览器马上要用到的，可以立刻发送对资源的请求，当需要用到该资源时就可以直接用而不用等待请求和响应的返回了
* prefetch是当前页面用不到但下一页面可能会用到的资源，优先级较低，只有当浏览器空闲时才会请求prefetch标记的资源。

从应用层面上看，preload和server push并没有什么区别，但是server push减少浏览器请求的时间，略优于preload，在一些场景中，可以将两者结合使用。
