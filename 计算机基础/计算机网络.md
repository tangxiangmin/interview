计算机网络
===
参考：
* [《网络是怎样连接的》读书笔记](http://www.shymean.com/article/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0)
* [《计算机网络-自顶向下的方法》读书笔记](https://www.shymean.com/article/《计算机网络-自顶向下的方法》读书笔记)

## 问题
* TCP三次握手和四次挥手
* url从地址栏输入到展示整个页面发生了什么
* 状态码
* 缓存控制
* Token及JSON Web Token认证原理
* Cookie、Session、LocalStorage和SessionStorage的作用及差异
* https
* HTTP2

## 协议分层

参考：[协议分层](https://www.shymean.com/article/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0#1.3.%20%E5%8D%8F%E8%AE%AE%E5%88%86%E5%B1%82)

为了了解**url从地址栏输入到展示整个页面发生了什么**这个问题，需要对下面了解下面的概念

* DNS服务器解析域名
* HTTP报文
* TCP连接三次握手、四次挥手
* IP地址
* 广播MAC寻址
* 服务器CGI程序

## DNS是如何解析的
[传送门](../网络/DNS.md)

## HTTP 应用层 

[传送门](../网络/HTTP.md)

## 运输层

参考：
* [TCP为啥要3次握手和4次挥手？握两次手不行吗？](https://mp.weixin.qq.com/s/_pWRHVoYnPGym7GADLPUPw)

### TCP 三次握手
TCP连接操作的大致流程如下
* 第一步是在TCP模块创建表示控制信息的头部，
    * 设置发送方和接收方的端口号和SYN比特，通过头部中发送方和接收方的端口号可以找到要连接的套接字
    * 然后客户端的TCP模块委托IP模块发送包含TCP头部的网络包，
* 服务器的TCP模块会根据这个网络包的TCP头部信息找到需要连接的服务器套接字信息，并写入相关信息，修改为正在连接状态然后服务器的TCP模块会返回响应
    * 这个过程与客户端一样，创建控制信息的头部。
    * 此外在返回响应时还需要将ACK控制位设置为1，表示通信确认。
    * 然后服务器的TCP模块委托其IP模块发送响应数据包
* 客户端的TCP模块通过响应数据包的TCP头部信息确认连接服务器的操作是否成功，如果SYN为1则表示成功，此时会向客户端的套接字中写入服务器的IP地址、端口号等信息后，客户端需要将ACK比特设置为1然后发回服务器，告知服务器刚才的响应包已经收到

可以看见，上面一共进行了三次数据包的发送（客户端两次，服务器一次），因此被称为三次握手。

### TCP 四次挥手
在数据收发完成以后，就可以选择断开连接了。完成数据的发送的一方会断开过程，这里以服务器举例：
* 首先，服务器协议栈会生成包含断开信息的TCP头部（即将FIN比特设为1），接着委托IP模块发送，同时，服务器的套接字会记录断开操作的相关信息
* 客户端协议栈收到FIN为1的TCP头部时，会将客户端自己的套接字标记为进入断开的状态，同时向服务器发送一个ACK号表示确认收到服务器的断开操作
* 过了一会应用程序读取了全部的数据之后，客户端协议栈也会与服务器协议栈一样，生成一个包含断开信息FIN为1的包，委托IP模块发送给服务器
* 服务务器最后会返回包含ACK号的确认包，最后会删除对应的套接字

可以看见断开连接一共需要发送4个数据包（服务器两个，客户端两个），因此被称为四次挥手。

### UDP
TCP的三次握手和四次挥手可以确保数据的准确性，但会导致效率下降，在某些对数据准确性不做要求的场景如DNS服务器查询、音视频数据都采用UDP传输

## 网络层

### IP地址

路由器的端口是以实际的发送方和接收方来收发网络包的，因此路由器的每个端口都具有MAC地址和IP地址，只接受与自身地址匹配的包。

路由器根据IP地址表来判断转发目标，实际上这里的IP地址只包含表示子网的网络号部分的比特值（这里就体现了子网掩码的作用，即表示在匹配网络包目标地址时需要对比的比特数量），而表示主机号部分的比特值全部为0（这与交换机不同，交换机会匹配完整的MAC地址），这样就可以将多条某个子网的IP导向同一个端口。

有时候可能会匹配多条子网记录，此时路由器会寻找网络号比特位最长的（网络号越长，说明主机号越短，子网内可分配的主机越少，可以缩小目标范围），如果网络号比特位相等，则匹配跃点数最小的记录。

有时地址本身的子网掩码和路由表 中的子网掩码是不一致的，这是路由聚合的结果。路由聚合会将几个子 网合并成一个子网，并在路由表中只产生一条记录。经过路由聚合，多个子网会被合并成一个子网，子网掩码会发生 变化，同时，目标地址列也会改成聚合后的地址。

IP协议可以根据IP地址来查找包的传输方向，从而确定下一个路由器的位置，因此在传输过程中，IP头部是不会变化的，而MAC头部的信息会随着到达的路由器而改变。

### Mac地址

MAC地址是网卡生产时写入ROM里的，具有全球唯一性。网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块。

发送方的MAC地址比较简单，只需要读取网卡中的MAC地址并将它写入MAC头部即可。

接收方的MAC地址比较麻烦，需要执行根据IP地址查询MAC地址的操作。采用的是以太网中的ARP（广播）技术，即将包发给连接在同一以太网中的所有设备，然后询问某个IP地址所属设备的MAC地址，获得的MAC地址后，将其写入MAC头部的接收方MAC地址。一般会进行ARP缓存加快查询操作。

## 链路层和物理层
从计算机出来的网络包会经过集线器、交换机和路由器等设备被转发，最终到达目的地
* 集线器
* 交换机
* 路由器


## 服务器响应
一般的做法是每有一个客户端连接进来，就fork一个新的服务器程序，如PHP
* 服务器程序包含两个模块，等待连接模块和负责与客户端通信的模块
* 服务器启动后完成初始化操作，运行等待模块，创建套接字，等待客户端的连接
* 接收到客户端连接时，等待模块会恢复运行并接收连接，然后启动服务器的客户端通信模块，并移交完成连接的套接字
* 每次有新的客户端发起连接，都会启动一个新的客户端通信模块（这个过程需要消耗服务器性能），因此通信模块与客户端是一对一的关系


## CDN
参考：[使用CDN](https://www.shymean.com/article/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BD%91%E7%AB%99%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%8F%98%E5%BF%AB#4.%20%E4%BD%BF%E7%94%A8CDN)

CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现，当业务需要接入到 CDN 时，用户只需调整自己的 DNS 配置信息，将 A 记录改为 CNAME 记录，将内容改为 CDN 厂商所提供的接入域名即可。

* 由于CDN对域名解析过程进行了调整，所以解析函数库得到的是该域名对应的CNAME记录，
* 为了得到实际的CDN服务器地址，浏览器需要再次对获得的CNAME进行解析，使用全局的负载均衡，分配靠近用户的CDN缓存服务器
* 缓存服务器根据浏览器提供的需要访问的域名，使用内部专用DNS解析得到此域名的实际IP，向该原始服务器请求数据，一方面缓存数据，一方面返回给浏览器，后续访问在缓存失效前可直接返回缓存
* 浏览器不在意数据从何处返回，能以较小延迟返回即可

未使用CDN，请求域名过程如下
* 用户向浏览器提供要访问的域名；
* 浏览器调用域名解析函数库对域名进行解析，以得到此域名对应的IP地址；
* 浏览器使用所得到的IP地址，域名的服务主机发出数据访问请求；
* 浏览器根据域名主机返回的数据显示网页的内容。


> CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现

**当业务需要接入到 CDN 时，用户只需调整自己的 DNS 配置信息，将 A 记录改为 CNAME 记录，将内容改为 CDN 厂商所提供的接入域名即可。**

使用了CDN，请求域名过程如下
* 用户向浏览器提供要访问的域名；
* 浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库得到的是该域名对应的CNAME记录（由于现在已经是使用了CDN服务，CNAME为CDN服务商域名）
* 为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；
    * 在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。（CDN服务来提供最近的机器）
    * 此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器发出访问请求；
    * 缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求；
* 缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程；
* 客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。
